#!/usr/bin/env python
# coding: utf-8

# LICENSE:

#  Copyright 2024 Kody Moodley

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

# http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# DESCRIPTION:
 
# This script generates two plain text witnesses from a TEI-XML transcription of a witness containing internal variation.
# 
# It does this by treating the edit operations in the TEI-XML document in two ways:
# 
# 1. Witness 1a is generated from the XML document by applying only the edit operations marked with the 'instant' attribute to the document. It ignores all other edit operations.
# 2. Witness 1b is generated by applying all the edit operations to the document.

from bs4 import BeautifulSoup
from bs4.element import Tag
import re
from typing import List
import argparse
from pathlib import Path

ADD = 'add'
DELETE = 'del'
SUBSTITUTION = 'subst'
ID = 'id'
INSTANT = 'instant'

def _is_child_of(edit1 : Tag, edit2 : Tag) -> bool:
    if (edit1.name in [ADD, DELETE, SUBSTITUTION]) and (edit2.name in [ADD, DELETE, SUBSTITUTION]):
        children = edit2.findChildren(re.compile('.*') , recursive=False)
        if edit1 in children:
            return True
        else:
            return _is_child_of_entity_in(edit1, children)
    return False
        
def _is_child_of_entity_in(edit : Tag, edits : List[Tag]) -> bool:
    for e in edits:
        if _is_child_of(edit, e):
            return True
    return False

def filter_child_edits(edits: List[Tag]) -> List[Tag]:
    result = []
    for edit in edits:
        if (not _is_child_of_entity_in(edit, edits) and (edit.name in [ADD, DELETE, SUBSTITUTION])):
            result.append(edit)
    return result

def _get_deepest_nested_tag(list_of_tags : List[Tag]) -> Tag:
    deepest = {'tag' : None, 'depth' : -1}
    for tag in list_of_tags:
        tag_depth = {'tag' : tag, 'depth' : _get_tag_nesting_depth(tag, depth=1)}
        if tag_depth['depth'] > deepest['depth']:
            deepest = tag_depth
    return deepest['tag']

def _get_tag_nesting_depth(tag : Tag, depth=1) -> int:
    children = tag.findChildren(re.compile('.*') , recursive=False)
    if len(children) == 0:
        return depth
    else:
        depth += 1
        return _get_tag_nesting_depth(_get_deepest_nested_tag(children), depth=depth)
    
def _apply_multiple_edit_ops(soup_obj : BeautifulSoup, edit_ids=[], edit_ops=[]) -> BeautifulSoup:
    if ((len(edit_ids) == 0) and (len(edit_ops) == 0)):
        raise Exception('No edit operations specified.')
    elif (len(edit_ids) == 0):
        for edit_op in edit_ops:
            if (type(edit_op) is not Tag):
                raise Exception('Edit operation: ', edit_op, ' is not a valid edit operation ID. Must be an integer greater equal to 1.')            
            else:
                soup_obj = _apply_single_edit_op(soup_obj, edit_op=edit_op)          
    elif (len(edit_ops) == 0):
        for edit_id in edit_ids:
            if (int(edit_id) < 1):
                raise Exception('Edit ID: ', edit_id, ' is not a valid edit operation ID. Must be an integer greater equal to 1.')
            else:
                soup_obj = _apply_single_edit_op(soup_obj, edit_id=edit_id)
    else:
        for edit_id in edit_ids:
            if (int(edit_id) < 1):
                raise Exception('Edit ID: ', edit_id, ' is not a valid edit operation ID. Must be an integer greater equal to 1.')
            else:
                soup_obj = _apply_single_edit_op(soup_obj, edit_id=edit_id)        
    return soup_obj

def _ignore_multiple_edit_ops(soup_obj : BeautifulSoup, edit_ids=[], edit_ops=[]) -> BeautifulSoup:
    if ((len(edit_ids) == 0) and (len(edit_ops) == 0)):
        raise Exception('No edit operations specified.')
    elif (len(edit_ids) == 0):
        for edit_op in edit_ops:
            if (type(edit_op) is not Tag):
                raise Exception('Edit operation: ', edit_op, ' is not a valid edit operation ID. Must be an integer greater equal to 1.')            
            else:
                soup_obj = _ignore_single_edit_op(soup_obj, edit_op=edit_op)          
    elif (len(edit_ops) == 0):
        for edit_id in edit_ids:
            if (int(edit_id) < 1):
                raise Exception('Edit ID: ', edit_id,' is not a valid edit operation ID. Must be an integer greater equal to 1.')
            else:
                soup_obj = _ignore_single_edit_op(soup_obj, edit_id=edit_id)
    else:
        for edit_id in edit_ids:
            if (int(edit_id) < 1):
                raise Exception('Edit ID: ', edit_id, ' is not a valid edit operation ID. Must be an integer greater equal to 1.')
            else:
                soup_obj = _ignore_single_edit_op(soup_obj, edit_id=edit_id)        
    return soup_obj

def _apply_single_edit_op(soup_obj : BeautifulSoup, edit_id=-1, edit_op=None) -> BeautifulSoup:
    if ((edit_id == -1) and (edit_op is None)):
        raise Exception('A valid edit operation is not specified.')
    elif (edit_id == -1):
        if (type(edit_op) is not Tag):
            raise Exception('Edit operation: ', edit_op, ' is not a valid bs4.element.Tag object')
        else:
            tag_nesting_depth = _get_tag_nesting_depth(edit_op)
            if (tag_nesting_depth == 1):
                if (edit_op.name == ADD):
                    if soup_obj.find(ADD, {ID: edit_op[ID]}) is not None:
                        soup_obj.find(ADD, {ID: edit_op[ID]}).string = re.sub(r'\s+', ' ', soup_obj.find(ADD, {ID: edit_op[ID]}).get_text().strip())
                        soup_obj.find(ADD, {ID: edit_op[ID]}).unwrap()
                elif (edit_op.name == DELETE):
                    if soup_obj.find(DELETE, {ID: edit_op[ID]}) is not None:
                        soup_obj.find(DELETE, {ID: edit_op[ID]}).string = re.sub(r'\s+', ' ', soup_obj.find(DELETE, {ID: edit_op[ID]}).get_text().strip())
                        soup_obj.find(DELETE, {ID: edit_op[ID]}).extract()
                elif (edit_op.name == SUBSTITUTION):
                    if soup_obj.find(SUBSTITUTION, {ID: edit_op[ID]}) is not None:
                        soup_obj.find(SUBSTITUTION, {ID: edit_op[ID]}).string = re.sub(r'\s+', ' ', soup_obj.find(SUBSTITUTION, {ID: edit_op[ID]}).get_text().strip())
                        soup_obj.find(SUBSTITUTION, {ID: edit_op[ID]}).unwrap()
            else:
                children = edit_op.findChildren(re.compile('.*') , recursive=False)
                count = 1
                for child in children:
                    soup_obj = _apply_single_edit_op(soup_obj, edit_op=child)
                    count += 1
                soup_obj = _apply_single_edit_op(soup_obj, edit_op=edit_op)
    return soup_obj
        
def _ignore_single_edit_op(soup_obj : BeautifulSoup, edit_id=-1, edit_op=None) -> BeautifulSoup:
    if ((edit_id == -1) and (edit_op is None)):
        raise Exception("A valid edit operation is not specified.")
    elif (edit_id == -1):
        if (type(edit_op) is not Tag):
            raise Exception("Edit operation",edit_op,"is not a valid bs4.element.Tag object")
        else:
            tag_nesting_depth = _get_tag_nesting_depth(edit_op)
            if (tag_nesting_depth == 1):
                if (edit_op.name == ADD):
                    if soup_obj.find(ADD, {ID: edit_op[ID]}) is not None:
                        soup_obj.find(ADD, {ID: edit_op[ID]}).extract()
                elif (edit_op.name == DELETE):
                    if soup_obj.find(DELETE, {ID: edit_op[ID]}) is not None:
                        soup_obj.find(DELETE, {ID: edit_op[ID]}).unwrap()

            else:
                children = edit_op.findChildren(re.compile('.*') , recursive=False)
                count = 1
                for child in children:
                    _ignore_single_edit_op(soup_obj, edit_op=child)
                    count += 1
                _ignore_single_edit_op(soup_obj, edit_op=edit_op)
    return soup_obj

def _clean_soup(soup : BeautifulSoup) -> BeautifulSoup:
    while soup.body is not None:
        soup.body.unwrap()
        
    while soup.hi is not None:
        soup.hi.unwrap()

    while soup.pb is not None:
        soup.pb.unwrap()

    while soup.div is not None:
        soup.div.unwrap()

    while soup.foreign is not None:
        soup.foreign.extract()

    while soup.unclear is not None:
        soup.unclear.extract()

    while soup.signature is not None:
        soup.signature.unwrap()

    while soup.metamark is not None:
        soup.metamark.unwrap()

    t = soup.find('name')
    while t is not None:
        t.unwrap()
        t = soup.find('name')
    
    while soup.sic is not None:
        soup.sic.unwrap()
    
    while soup.lb is not None:
        soup.lb.unwrap()

    while soup.subst is not None:
        soup.subst.unwrap()
        
    while soup.p is not None:
        soup.p.unwrap()
        
    while soup.title is not None:
        soup.title.unwrap()

    while soup.alt is not None:
        soup.alt.unwrap()

    while soup.seg is not None:
        soup.seg.unwrap()

    while soup.gap is not None:
        soup.gap.extract()
        
    return soup

def _do_second_clean(soup : BeautifulSoup) -> BeautifulSoup:
    while soup.head is not None:
        soup.head.unwrap()
    
    while soup.subhead is not None:
        soup.subhead.unwrap()
            
    return str(soup)

def add_ids_to_edit_ops(filepath: str) -> BeautifulSoup:
    """ Adds unique identifiers to each edit operation in the input TEI/XML document

    Args:
        filepath (str) : Path to the input TEI/XML document

    Returns:
        BeautifulSoup: the modified document containing the unnique IDs for the edit operations.

    """

    with open(filepath, 'r') as file:
        soup = BeautifulSoup(file, features='lxml-xml')

    add_tag_counter = 1
    del_tag_counter = 1
    subst_tag_counter = 1

    for tag in soup.find_all():
        if tag.name == ADD:
            tag[ID] = add_tag_counter
            add_tag_counter += 1
        elif tag.name == DELETE:
            tag[ID] = del_tag_counter
            del_tag_counter += 1
        elif tag.name == SUBSTITUTION:
            tag[ID] = subst_tag_counter
            subst_tag_counter += 1

    return soup

def generate_witness_1a(soup_witness_1a: BeautifulSoup, soup_base: BeautifulSoup) -> BeautifulSoup:
    """Generate Witness 1a by applying only instant edits.

        Args:
            soup_witness_1a (BeautifulSoup): The BeautifulSoup object representing the witness to be edited.
            soup_base (BeautifulSoup): A BeautifulSoup object representing the original witness (to keep a reference to the original unedited witness)
        
        Returns:
            BeautifulSoup: a soup object represented the edited witness (Witness 1a)
    """
    top_level_tags = filter_child_edits(soup_witness_1a.find_all())
    
    # Apply instant edits to the witness
    for tag in soup_witness_1a.find_all():
        if tag.has_attr(INSTANT) and tag[INSTANT].lower() == 'true':
            soup_witness_1a = _apply_single_edit_op(soup_witness_1a, edit_op=tag)
    
    # Identify non-instant edits to ignore
    edits_to_ignore: List[Tag] = []
    
    for tag in soup_witness_1a.find_all():
        if (not tag.has_attr(INSTANT)) or (tag[INSTANT].lower() == 'false'):
            if tag in top_level_tags:
                edits_to_ignore.append(tag)
    
    # Revert non-instant edits using the ignore function
    return _ignore_multiple_edit_ops(soup_witness_1a, edit_ops=edits_to_ignore)

def generate_witness_1b(soup_witness_1b: BeautifulSoup) -> BeautifulSoup:
    """Generate Witness 1b by applying all edits.

        Args:
            soup_witness_1b (BeautifulSoup): The BeautifulSoup object representing the witness to be edited.
        
        Returns:
            BeautifulSoup: a soup object represented the edited witness (Witness 1b)
    """
    # Generate Witness 1b (all edits applied)
    top_level_tags = filter_child_edits(soup_witness_1b.find_all()) # Identify all top-level tags (not child edits within nested ones)
    return _apply_multiple_edit_ops(soup_witness_1b, edit_ops=top_level_tags)

def write_witness_to_file(xml_input_filepath: str, soup_witness: BeautifulSoup, witness_id: str, output_file_ext: str) -> None:
    """Writes the content of the witness soup object to a text file.
    
    Args:
        xml_input_filepath (str): The file path of the input XML file
        soup_witness (BeautifulSoup): The BeautifulSoup object representing the witness
        witness_id (str): suffix for output filename e.g., '1a' or '1b' or 'ids_added'
        output_file_ext (str): file extension for output filename
        
    Raises:
        ValueError: If the file path does not have a valid extension.
    """

    # Split the input file path into the filename and extension
    filepath_parts = str(xml_input_filepath).rsplit('.', 1)
    
    if len(filepath_parts) != 2:
        raise ValueError('No valid file extension specified for the input file.')

    filename, file_extension = filepath_parts  # Ignoring the original file extension
    output_file_witness = f'{filename}_{witness_id}.{output_file_ext}'  # Always output to a .txt file

    # Write the text content of the soup_witness to the output file
    with open(output_file_witness, 'w', encoding='utf-8') as outfile:
        outfile.write(soup_witness.get_text())
        
def clean_soup_object(soup: BeautifulSoup) -> BeautifulSoup:
    # Clean unwanted characters and content from XML structure
    cleaned_soup = _clean_soup(soup.body)
    cleaned_soup = re.sub(r'(?=>).\s*', '>', str(cleaned_soup))
    cleaned_soup = re.sub(r'\s+(?=<)', ' ', cleaned_soup)
    cleaned_soup = cleaned_soup.replace('</head>','</head>\n\n').replace('</subhead>', '</subhead>\n\n')
    cleaned_soup = _do_second_clean(BeautifulSoup(cleaned_soup, "lxml-xml"))

    # Create a fresh soup object withe cleaned XML structure
    cleaned_soup_result = BeautifulSoup(cleaned_soup, features="lxml-xml")
    return cleaned_soup_result
    
def main() -> None:
    parser = argparse.ArgumentParser(description="TEIXML2TEXT generates two plain witnesses from a single TEI/XML witness with internal edits. The first witness will be the result of applying only instant edits in the XML file, while the second will be the result of applying all edits")
    parser.add_argument('--input', type=str, help="The path to the input TEI/XML file.")
    args = parser.parse_args()

     # Validate the input file path
    input_file = Path(args.input)
    if not input_file.is_file():
        raise FileNotFoundError(f"The input file does not exist: {args.input}")
    if not input_file.suffix.lower() == '.xml':
        raise ValueError(f"The input file is not an XML file: {args.input}")
    
    soup_base = add_ids_to_edit_ops(input_file)
    write_witness_to_file(input_file, soup_base, 'ids_added', 'xml')

    soup_w_cleaned = clean_soup_object(soup_base)
    soup_w1a = BeautifulSoup(str(soup_w_cleaned), features="lxml-xml")
    soup_w1b = BeautifulSoup(str(soup_w_cleaned), features="lxml-xml")
    
    write_witness_to_file(input_file, generate_witness_1a(soup_w1a, soup_base), '1a', 'txt')
    write_witness_to_file(input_file, generate_witness_1b(soup_w1b), '1b', 'txt')

if __name__ == "__main__":
    main()
